# chat-frontend

Front end for [Slack](https://slack.com)-ish chat application.
Author Perttu Kärnä

## Tech stack

Core technologies used:

* [Angular (v5)](https://github.com/angular/angular-cli) (project originally generated with angular-cli)
* [Redux](https://github.com/angular-redux/store) for state management
* [Angular Materials](https://material.angular.io) for UI components
* [Karma](https://karma-runner.github.io) for unit tests
* [Protractor](http://www.protractortest.org/) for e2e tests

## General structure

### Source

The source code can be found under [app](src/app) -folder. The code is structured in following way:

* Redux action definitions can be found under [actions](src/app/actions) -folder
* HTTP request module and middleware for handling asynchronous actions are under [middleware](src/app/middleware) -folder
* Models are defined at [models](src/app/models) -folder
* Redux reducers are under [store](src/app/store) -folder
* UI components are at [view](src/app/view) -foler
* Angular app module declarations and base app component are at [app](src/app) -folder

### Base principles shortly

In a very high level this app can be split into two parts: store (manages the app state), and UI components. Let's start by store.

Redux store is a source of truth, a place where all the app data lies and from where the components get the state. Redux store is immutable in a way; you can't manipulate the data in store directly. However, you can dispatch **actions**, and provide data within them. Those actions will flow through Redux **middleware**, where a handlers called **reducers** handle the action. The action contains at least a type attribute, so the reducers can determine which action has been dispatched. In this application, also data can be passed in the action, which the reducers will handle. The reducers receive the old store with the action, and they return a new store. Thus, they create the new store by manipulating the old one and possibly mix in some action data. I.e all HTTP requests flow through Redux middleware and reducers, so that the app state can be kept updated when receiving new data from back end.

Angular offers many kinds of modules (components, services, directives, pipes), but we're going to focus only to components. Angular components and React components have many similarities. Angular component is a ES6 class, which is assigned to a certain HTML template and CSS file. Angular supports two-way binding, which makes it easy to create dynamic UIs. It is recommended to keep components simple (one-purpose-principle), so that they're easy to maintain. Components can of course be called from another component.

To wrap these two into together, we use objects called [Observables](https://xgrommx.github.io/rx-book/content/observable/index.html). Observables are handy when handling asynchronous data. They remind a bit [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), but they're more flexible for continuous data flow. When we want to get something from the Redux store, we'll have to declare a selector for the component using the data from the store. The selector is usually a function, and it will return an observable. The observable can then be used in multiple ways. i.e. by subscribing it in UI component constructor and in that way receiving the updated data whenever it changes. When the store is managed correctly, Angular will handle updating the UI when necessary.

## Commands

* Install dependencies by `npm install`
* Run the development server by `npm start`
* Build a production build by `npm run build`
* Run unit tests by `npm test`
* Run e2e tests by `npm run e2e`

**NOTE**: (29.12.2017) Tests can't be run at the moment due to some broken configurations during updating all dependencies.

### To run the development server

1. Install dependencies
2. Configure API url at src/environments (default http://localhost:3000)
3. Run the development server
4. Stop the server by **Ctrl + C**

## Thanks to

### Fonts

* [ETNA](https://wildtype.design/product/etna-free-typeface/) by Krišjānis Mežulis
* Transformed from .otf to .woff and .ttf with [Onlinefontconverter](https://onlinefontconverter.com/)

### Images

* Billel Moula and [Pexels](https://www.pexels.com/photo/clouds-cold-frost-frosty-540518/)


**Original documentation generated by angular-cli below**
**NOTE**: The webpack development configurations have been ejected by running `ng eject`. Thus, use only npm scripts to run jobs.

---

This project was generated with [angular-cli](https://github.com/angular/angular-cli) version 1.0.0-beta.28.3.

## Development server
Run `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The app will automatically reload if you change any of the source files.

## Code scaffolding

Run `ng generate component component-name` to generate a new component. You can also use `ng generate directive/pipe/service/class/module`.

## Build

Run `ng build` to build the project. The build artifacts will be stored in the `dist/` directory. Use the `-prod` flag for a production build.

## Running unit tests

Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

## Running end-to-end tests

Run `ng e2e` to execute the end-to-end tests via [Protractor](http://www.protractortest.org/).
Before running the tests make sure you are serving the app via `ng serve`.

## Deploying to GitHub Pages

Run `ng github-pages:deploy` to deploy to GitHub Pages.

## Further help

To get more help on the `angular-cli` use `ng help` or go check out the [Angular-CLI README](https://github.com/angular/angular-cli/blob/master/README.md).
